# Bash-скрипты, часть 5: функции и разработка библиотек
Оболочка bash предоставляет возможность создавать функции. Функцию в bash можно объявить 2-мя способами:
```shell
functionName {
}

functionName1() {
}
```

Для вызова функции в скрипте, достаточно указать её имя.
```shell
function myfunc {
echo "This is an example of using a function"
}
count=1
while [ $count -le 3 ]
do
myfunc
count=$(( $count + 1 ))
done
echo "End of the script"
```

Результат работы описанного скрипта:
```
This is an example of using a function
This is an example of using a function
This is an example of using a function
End of the script
```

Обратите внимание на то, что попытавшись использовать функцию до её объявления, вы столкнётесь с ошибкой.

### Использование команды return
Команда return позволяет задавать возвращаемый функцией целочисленный код завершения. То, что возвратила функция, находится в переменной $?.

Если вы выполните любую другую команду до извлечения из переменной $? значения, возвращённого функцией, это значение будет утеряно. Дело в том, что данная переменная хранит код возврата последней выполненной команды.

Учтите, что максимальное число, которое может вернуть команда return — 255. Если функция должна возвращать большее число или строку, понадобится другой подход.

Пример работы команды return:
```shell
function myfunc {
read -p "Enter a value: " value
echo "adding value"
return $(( $value + 10 ))
}
myfunc
echo "The new value is $?"
```

### Запись вывода функции в переменную
Ещё один способ возврата результатов работы функции заключается в записи данных, выводимых функцией, в переменную. Такой подход позволяет обойти ограничения команды return и возвращать из функции любые данные.

Пример использования такого подхода:
```shell
function myfunc {
read -p "Enter a value: " value
echo $(( $value + 10 ))
}
result=$( myfunc)
echo "The value is $result"
```

### Аргументы функций
Аргументы функции в bash работают также, как и параметры командной строки, переданные в скрипт.

Например, имя функции хранится в параметре $0, первый переданный ей аргумент — в $1, и так далее. Количество переданных функции аргументов хранится в переменной $#.

Пример работы с аргументами функции:
```shell
function addnum {
if [ $# -eq 0 ] || [ $# -gt 2 ]
then
echo -1
elif [ $# -eq 1 ]
then
echo $(( $1 + $1 ))
else
echo $(( $1 + $2 ))
fi
}
echo -n "Adding 10 and 15: "
value=$(addnum 10 15)
echo $value
echo -n "Adding one number: "
value=$(addnum 10)
echo $value
echo -n "Adding no numbers: "
value=$(addnum)
echo $value
echo -n "Adding three numbers: "
value=$(addnum 10 15 20)
echo $value
```

Обратите внимание на то, что функция не может напрямую работать с параметрами, которые переданы скрипту при его запуске из командной строки.

Передать массив в функцию в качестве аргумента не получится. Пример неправильного подхода:
```shell
myarray=(1 2 3 4 5)
echo "The original array is: ${myarray[*]}"
myfunc $myarray
```

Вместо этого следует передавать все элементы массива в качестве самостоятельных аргументов. Пример правильного подхода:
```shell
function myfunc {
newarray=("$@")
echo "The new array value is: ${newarray[*]}"
}
myarray=(1 2 3 4 5)
echo "The original array is ${myarray[*]}"
myfunc ${myarray[*]}
```

### Глобальные и локальные переменные
Принцип работы глобальных и локальных переменных в bash-скриптах такой же, как и в других языках программирования.

Отличие лишь в том, что все переменные в bash-скрипте по умолчанию считаются глобальными. Чтобы создать локальную переменную, перед её именем нужно дописать слово local, например:
```shell
local temp=$(( $value + 5 ))
```

### Создание и использование библиотек
Чтобы использовать в скрипте функции, описанные в другом файле, используется команда source или её псевдоним - оператор «точка».

Пример подключения функции из другого файла:

Содержимое файла myfuncs, являющегося библиотекой:
```shell
function addnum {
echo $(( $1 + $2 ))
}
```

Основной сценарий:
```shell
. ./myfuncs
result=$(addnum 10 20)
echo "The result is: $result"
```