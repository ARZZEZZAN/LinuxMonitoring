# Bash-скрипты, часть 3: параметры и ключи командной строки
Наиболее распространённый способ передачи данных сценариям заключается в использовании параметров командной строки. Выглядит это так:
```shell
$ ./myscript 10 20
```

Оболочка bash назначает специальным переменным, называемым позиционными параметрами, введённые при вызове скрипта параметры командной строки:
- $0 — имя скрипта.
- $1 — первый параметр.
- $2 — второй параметр.
- ...
- $9 — девятый параметр.
- ${10} - десятый параметр.

Вот как можно использовать параметры командной строки в скрипте с помощью этих переменных:
```shell
echo $0
echo ${11}
```

Обратите внимание на то, что параметры командной строки разделяются пробелами. Если параметр содержит пробелы, его следует заключить в кавычки.

### Проверка параметров
Проверку наличия параметров, переданных сценарию при вызове, можно организовать так:
```shell
if [ -n "$1" ]
then
echo Hello $1.
else
echo "No parameters found. "
fi
```

### Подсчёт параметров
Переменная $# содержит количество параметров, переданных сценарию при вызове.

Эта переменная даёт необычный способ получения последнего из переданных скрипту параметров, не требующий знания их количества. Вот как это выглядит:
```shell
echo The last parameter was ${!#}
```

### Захват всех параметров командной строки
В некоторых случаях нужно захватить все параметры, переданные скрипту. Для этого можно воспользоваться переменными $* и $@.

Переменная $* содержит все параметры, введённые в командной строке, в виде единого элемента.

Переменная $@ содержит все параметры, введённые в командной строке, в виде массива. С помощью этой переменной параметры можно перебирать в циклах.

### Команда shift
Команда shift, по умолчанию, сдвигает значения позиционных параметров влево. Например, значение переменной $3 становится значением переменной $2, значение $2 переходит в $1, а то, что было до этого в $1, теряется. Обратите внимание на то, что при этом значение переменной $0, содержащей имя скрипта, не меняется.

Воспользовавшись командой shift, рассмотрим ещё один способ перебора переданных скрипту параметров:
```shell
count=1
while [ -n "$1" ]
do
echo "Parameter #$count = $1"
count=$(( $count + 1 ))
shift
done
```

### Ключи командной строки

Ключи командной строки обычно выглядят как буквы, перед которыми ставится тире. Они служат для управления сценариями. Рассмотрим такой пример:
```shell
echo
while [ -n "$1" ]
do
case "$1" in
-a) echo "Found the -a option" ;;
-b) echo "Found the -b option" ;;
-c) echo "Found the -c option" ;;
*) echo "$1 is not an option" ;;
esac
shift
done
```

Запустим скрипт:
```shell
$ ./myscript –a –b –c –d
```

Вывод скрипта в терминале:
```shell
Found the -a option
Found the -b option
Found the -c option
-d is not an option
```

В этом коде использована конструкция case, которая сверяет переданный ей ключ со списком обрабатываемых скриптом ключей. Если переданное значение нашлось в этом списке, выполняется соответствующая ветвь кода. Если при вызове скрипта будет использован любой ключ, обработка которого не предусмотрена, будет исполнена ветвь «*».

### Как различать ключи и параметры
Часто при написании bash-скриптов возникает ситуация, когда надо использовать и параметры командной строки, и ключи. Стандартный способ это сделать заключается в применении специальной последовательности символов, которая сообщает скрипту о том, когда заканчиваются ключи и начинаются обычные параметры.

Эта последовательность — двойное тире. Оболочка использует её для указания позиции, на которой заканчивается список ключей. Рассмотрим пример:
```shell
while [ -n "$1" ]
do
case "$1" in
-a) echo "Found the -a option" ;;
-b) echo "Found the -b option";;
-c) echo "Found the -c option" ;;
--) shift
break ;;
*) echo "$1 is not an option";;
esac
shift
done
count=1
for param in $@
do
echo "Parameter #$count: $param"
count=$(( $count + 1 ))
done
```

Этот сценарий использует команду break для прерывания цикла while при обнаружении в строке двойного тире.

Как видно, когда скрипт, разбирая переданные ему данные, находит двойное тире, он завершает обработку ключей и считает всё, что ещё не обработано, параметрами.

### Обработка ключей со значениями
По мере усложнения ваших скриптов, вы столкнётесь с ситуациями, когда обычных ключей уже недостаточно, а значит, нужно будет использовать ключи с некими значениями. Например, вызов сценария в котором используется подобная возможность, выглядит так:
```shell
./myscript -a test1 -b -c test2
```

Скрипт должен уметь определять, когда вместе с ключами командной строки используются дополнительные параметры. Приведём пример обработки ключа, который нуждается в параметре:
```shell
-b) param="$2"
echo "Found the -b option, with parameter value $param"
shift ;;
```

### Использование стандартных ключей
При написании bash-скриптов вы можете выбирать любые буквы для ключей командной строки и произвольно задавать реакцию скрипта на эти ключи. Однако, в мире Linux значения некоторых ключей стали чем-то вроде стандарта, которого полезно придерживаться. Вот список этих ключей:
- -a -- Вывести все объекты.
- -c -- Произвести подсчёт.
- -d -- Указать директорию.
- -e -- Развернуть объект.
- -f -- Указать файл, из которого нужно прочитать данные.
- -h -- Вывести справку по команде.
- -i -- Игнорировать регистр символов.
- -l -- Выполнить полноформатный вывод данных.
- -n -- Использовать неинтерактивный (пакетный) режим.
- -o -- Позволяет указать файл, в который нужно перенаправить вывод.
- -q -- Выполнить скрипт в quiet-режиме.
- -r -- Обрабатывать папки и файлы рекурсивно.
- -s -- Выполнить скрипт в silent-режиме.
- -v -- Выполнить многословный вывод.
- -x -- Исключить объект.
- -y -- Ответить «yes» на все вопросы.

### Получение данных от пользователя
Для ввода данных пользователем во время выполнения программы, в оболочке bash имеется команда read. После получения данных, эта команда помещает их в переменную:
```shell
echo -n "Enter your name: "
read name
```

Обратите внимание на то, что команда echo, которая выводит приглашение, вызывается с ключом -n. Это приводит к тому, что в конце приглашения не выводится знак перевода строки, что позволяет пользователю скрипта вводить данные там же, где расположено приглашение, а не на следующей строке.

При вызове read можно указывать и несколько переменных:
```shell
read -p "Enter your name: " first last
```

Если, вызвав read, не указывать переменную, данные, введённые пользователем, будут помещены в специальную переменную среды REPLY.
